Author	P.M.Cashin

Date	November 2009

Testing... #foo and #PEG etc..

----------------------------------------------------------------------------

Sect	The Gist Language

The Gist rules are defined as:

eg
	name = expression	-- a one-match rule
	name : expression	-- terminal string one-match rule


-------
	name -> label		-- rule defined in another grammar via a label

The grammar expression defining a rule can include any of these operators:

eg
	X/Y		choice of X else Y, first sequential match
	X Y		sequence X then Y, space or comma (X,Y)
	X*		any number of X
	X+		one or more X, same as: (X X*)
	X?		optional X, same as: (X / '')
	X~Y		X but not if Y, equivalent to: (!Y X)
	!X		not X, fails if X matches, else ''
	&X		asserts there is an X, same as: !!X
	(X)		group expression
	[X]		option, same as: X?
	{X}		repeat, same as: X*
	R		match rule R and generate a parse tree node
	`R		silent match with no parse tree node
	@R		match the same value matched by a prior R
	''		empty match (never fails)
	'a'		match a literal character
	'a'..'z'	match any character in this range
	'abc'		string match, short for: ('a' 'b' 'c')
	97		match a character with this code point, ie 'a'
	0x61		hex value code point match, ie 97 or 'a'
	0..127		match a character code in this range (eg ASCII chars)
	0x1..10FFFD	hex value code point range (eg Unicode chars)
	<event>		the parser generates an event (eg to <trace> progress)

eg
	X/Y		choice of X else Y, first sequential match
	X Y		sequence X then Y, space or comma (X,Y)
	X*		any number of X
	X+		one or more X, same as: (X X*)
	X?		optional X, same as: (X / '')
	X-Y		X but not if Y, equivalent to: (!Y X)
	!X		not X, fails if X matches, else ''
	&X		asserts there is an X, same as: !!X
	(X)		group expression
	[X]		option, same as: X?
	{X}		repeat, same as: X*
	R		match rule R and generate a parse tree node
	`R		silent match, a macro rule with no parse tree node
	@R		match the same value matched by a prior R
	''		empty match (never fails)
	'a'		match a literal character
	'a'..'z'	match any character in this range
	'abc'		string match, short for: ('a' 'b' 'c')
	97		match a character with this code point, ie 'a'
	0x61		hex value code point match, ie 97 or 'a'
	0..127		match a character code in this range (eg ASCII chars)
	0x1..10FFFD	hex value code point range (eg Unicode chars)
	~		matches any number of white-space characters
	$		matches a line-end (any of the standard conventions)
	_		matches any character code (any positive integer)
	<event>		the parser generates an event (eg to <trace> progress)

The :X and :Y stand for any grammar expression, while the :R stands for a rule name. The binding strength, or precedence, increases from the top of the list, to the highest precedence at the bottom. Thus:

eg
	R = X Y+ Z / !P Q '0'..'9'*

is equvalent to:

eg
	R = ( (X (Y+) Z)
	  / ((!P) Q ('0'..'9')*) );

A rule definition may use an explicit :[";"] as a terminator, and this allows multiple rules to appear on the same line. A rule may continue on the next line if there is a choice :["/"] or an unclosed bracket, but each line is taken as a group expression so an explicit comma :[","] or parenthesis are required to continue a sequence group into the next line.


Sub1	Choice Operators

The first sequential choice operator, written as :[X / Y], will first try to match :X, and only if that fails will the second choice :Y be matched. This is the [ref:PEG] sequential choice operator.


Sub1	Repeat Operators

The repeat operators are:

eg
	X?		optional match		X / ''
	X*		zero or more		Xs = X Xs.. / ''
	X+		one or more		Xp = X Xp.. / X

The repeat operators are "greedy" and will find the longest match, and no other.

The traditional [ref:EBNF] notation is also available:

eg
	{ X }		zero or more X, same as X*
	[ X ]		optional X, same as X?

The number of repeats may be specified explicitly, for example:
 
eg
	X*4		match exactly 4 times
	X*4.._		match 4 or more times
	X*4..8		match a min of 4 to a max of 8 times
------



Sub1	Same Match Operator

The :[@] operator is a context-sensitive operator that allows a grammar rule to use prior information from the (partial) parse tree constructed from the preceding input string.

eg
	@name	-- matches the same string that the prior name rule matched

The prior node is defined as the closest node generated with the given name that is a previous sibling node, or a parent, or a previous sibling of the parent, and so on back up to the root node.

This operator enables a Gist grammar to define languages that are beyond context-free grammar rules. It is rarely needed, but there are a few practical language features that can not be defined without it. Some examples are given a little later.


Sub1	Silent Match

A back-tick prefix :["`"] can be used to invoke a rule without generating a parse tree node. This makes no difference to the syntax defined by the grammar rules, it only effects the parse tree that will be generated.

For example, the next grammar defines a list of :int terms separated with :sep terms, but the back-tick prefix eliminates the :sep term from appearing in the parse tree:

eg
	list  = int (`sep int)*
	int   : '0'..'9'+
	sep   : s* ',' s*	-- comma and whitespace
	s     : 9..13/' '	-- white-space

The input: :["12, 3, 45"] will generate the parse tree:

eg
	list
		int "12"
		int "3"
		int "45"


Sub1	Language Details

A Gist grammar can be used as a stand alone specification, but it can also be employed inside different application programming languages. To reduce distractions with the host programming language Gist accepts line comments with several common conventions:

eg
	--	as in Haskell or XML-like comments
	//	as in C or Java style
	#	as in a Shell or Ruby script language style

The Gist language avoids using the quote :["] and backslash :[\] characters to simplify the use of grammar rules in a literal string inside application programming languages where these characters may need to be escaped.


--------------------
Sect	Eliminating Multi-match Rules

The JSON specification uses traditional grammar rules that allows multi-match rules, yet they are intended to act as one-match rules, and can be transcribe directly into Gist one-match rules. This is usually the case, but sometimes a specification relies on multi-match being able to back off the first longest match and use a shorter match instead. These rules need to be detected and reformulated into one-match rules.

If :X and :Y are mutually exclusive, and :X can not match an empty string, then the one-match :[(X/Y)] rule is the same as the multi-match rule :[(X|Y)]. But a multi-match choice that is not mutually exclusive can match either choice, whereas a one-match choice will only match the first choice. Reversing the order of the :[(X/Y)] choice may be required, otherwise it may be necessary to re-factor and match in steps.

A multi-match repeat rule can match a list of items as :[(X* Y)] even when an :X can also match a :Y. This takes advantage of the fact that a multi-match repeat can back-off from the last :X to accommodate the following :Y. The :X may match a prefix (or all) of :Y, but the grammar can still distinguish the last element. This is a common trick in regular expressions where the :[X*] may skip every character, but backtracking still allows the :Y to be matched at the end of the input.

For example, here is a traditional multi-match rule that would fail as a one-match rule. It matches :p or :q any number of times, but they must be followed by a :q :

eg	S ::= (p|q)* q    -- "q", "qq", "pq", "pqq", "ppq", "pqpq", "pqpqq", and so on...

The repeat operator will first match every :p or :q, so the following :q must fail, and a one-match version of this rule will fail. But the multi-match rule can back-track to a shorter sequence in the repeat operator, and thereby match the final :q.

The ~shortest string ending with a :q is simply:

eg	S = p* q

This ~longest string of :p or :q that ends with a :q can be expressed as:

eg	S = (p* q)*

This one-match rule matches the same longest string as the original multi-match rule.

A general approach for a longest one-match rule is to use a not-predicate to stop the repeat operator from matching an end condition:

eg	S = (p / q !end)* q

The end condition may match the end of the input string (not any character), or some other termination syntax.
-------------


____
For example, a :digit rule can refer to the :Nd, Numeric-digit defined in a :[Unicode.category] grammar:

eg	digit -> Unicode.category#Nd

If the local rule uses the same name as the rule in the external grammar then simply: 

eg	Zs -> Unicode.category

When multiple rule names refer to the same names in an external grammar then a catch-all reference can be used for convenience:

eg
	_ -> Unicode.category

Multiple catch-all references will be searched in the order they are given.

Rule names must be unique within a grammar, but external references can import different rules from different grammars that have the same rule name. The parse tree nodes use rule names, but they can be distinguished by their path names in the parse tree. Grammars are named in a separate name space, and these names do not appear in the parse tree.

A grammar may be given almost any name, but for grammars to be shared they need a globally unique name, so a good practice is to use a standard [ref:URI]. The extension :[#name] to designate a rule name within a grammar fits the general URI format. A URI can also lead to related web-pages with other documentation and resources provided by the URI web-site authority.


-----
Not only does the :[":"] notation express the desired parse tree, but it also allows the parser to make significant optimizations. For example, consider this rule which defines a hex digit:

eg
	hex = digit / 'a'..'f' / 'A'..'F'

This rule defines a :hex digit as either a :digit, or a letter in the ranges defined. The parser can combine the literal letters into a character set that only needs a single operator to match the input, but it can not combine the letters with the digits since the rule says that a :digit node should appear in the parse tree. Almost certainly that is not the intention, but without the :[":"] notation the parser can not presume to optimize the :hex rule into matching a single character set of digits and letters. This prevents the use of a single input matching operation for the composite :hex rule, but with a :[":"] rule it can be optimized to a single input match.

Traditional grammars are often implemented with a front-end lexical scanner that identifies terminal symbol strings. In Gist the :[":"] rules are used to match terminal strings.
----

