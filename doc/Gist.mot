
Title	The Gist Grammar Language

Author	P.M.Cashin

Date	November 2009

Sect	Introduction

Gist is a grammar language that defines both an input syntax and an output parse tree structure. This allows a universal parser to directly execute any Gist grammar. Application programs can use a Gist grammar to match an input string just as easily as using a regular expression.

For example, the grammar for a date format may be defined as:

eg
	Date  = day '/' month '/' year
	day   : d d?
	month : d d?
	year  : d d d d
	d     : '0'..'9'

This grammar defines a European date format, so [:"9/11/2001"] is the 9th of November, not the 11th of September. The grammar rules name syntactic elements, and this gives a semantic meaning to the date format. The :day and :month will match one or two digits, and the :year matches four digits. The general idea is easy to see, and the details will be explained shortly.

The Gist grammar rules can be directly used to label an input string. For example the [:Date] grammar will label the input string: [:"9/11/2001"] as:

eg
	Date
		day	"9"
		month	"11"
		year	"2001"

The grammar has been used as a pattern matcher to label the component parts of the input string, in other words the grammar rules have been used to parse the input string and generate a syntax parse tree. This is a simple and effective way for an application program to extract named fields from an input text string.

Grammar rules have more expressive power than regular expressions, but traditional grammar rules are difficult to implement and may require custom programming or the use of a parser generator to implement a parser for each new grammar. Gist is designed to support efficient direct evaluation.

For unambiguous computer languages Gist can be used to replace a traditional context-free grammar, and it can also define useful language features that are beyond a context-free grammar.


Sub1	Background

A grammar can be viewed as production rules that can generate all strings that belong to a language. The advantage of this view is that it does not prescribe exactly how to implement a parser for a grammar, in the same way that the specification for a sorted list does not prescribe a sorting algorithm. But in practice we often need to implement a parser that will match input strings in conformance to a grammar specification, and a traditional grammar specification says very little about how this should be done.

Both [ref:grammar theory] and [ref:parser technology] are well developed, and there are text books full of different parsers designed to solve this problem. There are a number of excellent tools and parser generators, such as [ref:ANTLR]. These tools can be used to develop high performance parsers for complex language grammars. But each new grammar typically requires the development of a new parser.

On the other hand there are many small mundane grammar specifications for network message formats, data base records, and many other applications, which do not warrant the development of individual custom parsers. These formats are often hand-coded inside various programs, perhaps with the help of a regular expression pattern matcher. Many of these applications could use a generic parser, but a traditional grammar specification has no way to express that. This is nicely summarized in [ref:Parsing Techniques] with the bon mot: "parsing is only a problem if someone else is in charge of the grammar".

Traditional grammar rules are multi-match rules, they can match in many different ways. But in practice computer languages are designed to be unambiguous, they need the grammar to match in only one way, and they can be written using one-match rules.

One-match rules correspond to a [ref:Parser Expression Grammar], which has been formally defined and shown to enable an efficient linear time parser. One-match rules are deterministic committed choice rules, the operators can not backtrack to try any other choices. One-match rules can be executed directly as top-down pattern matching rules.

A traditional grammar specifies an input language, but the parse tree that it generates depends on how it is derived from the grammar, which is considered to be a parser implementation issue. A Gist parser directly executes the grammar rules which defines the structure of the parse tree that will be generated. A programmer can use the grammar rules as a map to navigate and access the parse tree.

One-match rules restrict the expressive power of the grammar rules, since each operator makes a committed choice. But it turns out that for many applications the one-match rules are exactly what is required, and in practice it is not too difficult to eliminate multi-match rules. In fact multi-match rules often include unintentional rule matches that can not be eliminated in a traditional grammar specification.

For many years the [ref:IETF] has been using [ref:ABNF] grammar rules for Internet specifications. ABNF defines a context free grammar with multi-match rules, but the majority of IETF specifications only expect the first longest match. The odd specification that does take advantage of multi-match rules can be replaced with one-match rules that express the same result in a slightly different manner. On the other hand, there are a few IETF specifications that can not be fully specified in ABNF since they are beyond a context-free grammar.

In practice computer languages are almost always designed to fit a context-free grammar, although there are a few important exceptions. One important context-sensitive feature is the use of visual white-space to express a nested structure with an inset layout. This is so intuitive and expressive that it is often used in text book explanations even when discussing programming languages that do not support this feature. It is interesting to notice that the specification for the ABNF grammar rules themselves describes an inset layout, despite the fact that ABNF rules can not express that feature. Gist provides a context-sensitive operator that can be used to specify features like this if required.


Sect	The Gist Parse Tree

Gist rules are an intrinsic definition for the syntax tree that the parser will generate. Each rule is a node in the tree, and rules that it calls will generate its children nodes. As an example, a list of integer numbers separated by commas can be defined with a :list rule that is defined as a first :int followed by a comma character and another :int that can be repeated zero or more times, where the :int rule matches one or more digit:

eg
	list  = int (',' int)*
	int   = digit+
	digit = '0'..'9'

This grammar matches the string [:"12,3,45"], and generates the syntax parse tree:

eg
	list
		int
			digit	"1"
			digit	"2"
		int
			digit	"3"
		int
			digit	"4"
			digit	"5"

The rule name is used to label the input text that the rule matches. The :list is a composite term that matches the full input string with a list of :int rule names that match substrings. The :digit rule is a terminal rule that matches a digit character.

A top down procedural reading of the grammar rules will match a :list by first matching an :int which in turn matches one or more :digit, which matches the [:"1"] and the [:"2"] and that completes the first :int. The [:','] and the next :int is then matched, and this is repeated as many times as possible. The repeat operators are one-match operators that match as many input characters as possible (they are "greedy").

In this way the rules generate an intrinsic parse tree. Notice that the comma was matched with a literal character, without a named rule, so it does not appear as a term in the syntax tree structure.

In this example the tree is a bit verbose, we don't really need the :digit terms, we would like the :int rule to match a numeric string directly, as a terminal. This can be expressed in Gist by using end-value string matching rule, designated with [:":"] instead of [:"="], to generate a leaf node in the parse tree:

eg
	list = int (',' int)*
	int  : digit+
	digit: '0'..'9'

This grammar matches in exactly the same way, but it now generates the parse tree:

eg
	list
		int	"12"
		int	"3"
		int	"45"

The :int rule has been defined as a terminal rule that will generate a leaf node, and therefore the :digit rule will be absorbed into the :int rule, since it is only required to match digits, but without generating any :digit parse tree nodes.

Not only does the [:":"] notation express the desired parse tree, but it also allows the parser to make significant optimizations. For example, consider this rule which defines a hex digit:

eg	hex = digit / 'a'..'f' / 'A'..'F'

The parser can combine the letters into a character set that only needs a single operator to match the input, but it can not combine the letters with the digits since the rule says that a :digit node should appear in the parse tree. Almost certainly that is not the intention, but without the [:":"] notation the parser can not presume to optimize the :hex rule into matching a single character set of digits and letters. This prevents the use of a single input matching operation for the composite :hex rule, but with a [:":"] rule it can be optimized to a single input match.

Traditional grammars are often implemented with a front-end lexical scanner that identifies terminal symbol strings. In Gist the [:":"] rules are used to match terminal strings.

Another way to define a :list is with a choice operator, [:/], rather than a repeat operator:

eg
	list  = int ',' list / int
	int   : digit+
	digit : '0'..'9'

The second option for a :list, the single :int, is only matched if the first option fails.

With these rules matching the string [:"12,3,45"], generates the parse tree:

eg
	list
		int	"12"
		list
			int	"3"
			list
				int	"45"

This tree has the structure: [:(12,(3,(45)))].

Yet another way to define a :list is:

eg
	list  = list ',' int / int
	int   : digit+
	digit : '0'..'9'

This grammar is left recursive, and a simple procedural reading will fall into a fruitless loop. But a top down parser can be extended to accommodate left recursion; more on this later. A Gist parser will generate this parse tree:

eg
	list
		list
			list
				int	"12"
			int	"3"
		int	"45"

This tree has the structure: [:(((12),3),45)].


Sect	The Gist Language

The Gist rules are defined as:

eg
	name = expression	-- a one-match rule
	name : expression	-- terminal string one-match rule
	name -> label		-- rule defined in another grammar via a label

The grammar expression defining a rule can include any of these operators:

eg
	X/Y		choice of X else Y, first sequential match
	X Y		sequence X then Y, space or comma (X,Y)
	X*		any number of X
	X+		one or more X, same as: (X X*)
	X?		optional X, same as: (X / '')
	X~Y		X but not if Y, equivalent to: (!Y X)
	!X		not X, fails if X matches, else ''
	&X		asserts there is an X, same as: !!X
	(X)		group expression
	[X]		option, same as: X?
	{X}		repeat, same as: X*
	R		match rule R and generate a parse tree node
	`R		silent match with no parse tree node
	@R		match the same value matched by a prior R
	''		empty match (never fails)
	'a'		match a literal character
	'a'..'z'	match any character in this range
	'abc'		string match, short for: ('a' 'b' 'c')
	97		match a character with this code point, ie 'a'
	0x61		hex value code point match, ie 97 or 'a'
	0..127		match a character code in this range (eg ASCII chars)
	0x1..10FFFD	hex value code point range (eg Unicode chars)
	<event>		the parser generates an event (eg to <trace> progress)

eg
	X/Y		choice of X else Y, first sequential match
	X Y		sequence X then Y, space or comma (X,Y)
	X*		any number of X
	X+		one or more X, same as: (X X*)
	X?		optional X, same as: (X / '')
	X-Y		X but not if Y, equivalent to: (!Y X)
	!X		not X, fails if X matches, else ''
	&X		asserts there is an X, same as: !!X
	(X)		group expression
	[X]		option, same as: X?
	{X}		repeat, same as: X*
	R		match rule R and generate a parse tree node
	`R		silent match, a macro rule with no parse tree node
	@R		match the same value matched by a prior R
	''		empty match (never fails)
	'a'		match a literal character
	'a'..'z'	match any character in this range
	'abc'		string match, short for: ('a' 'b' 'c')
	97		match a character with this code point, ie 'a'
	0x61		hex value code point match, ie 97 or 'a'
	0..127		match a character code in this range (eg ASCII chars)
	0x1..10FFFD	hex value code point range (eg Unicode chars)
	~		matches any number of white-space characters
	$		matches a line-end (any of the standard conventions)
	_		matches any character code (any positive integer)
	<event>		the parser generates an event (eg to <trace> progress)

The :X and :Y stand for any grammar expression, while the :R stands for a rule name. The binding strength, or precedence, increases from the top of the list, to the highest precedence at the bottom. Thus:

eg
	R = X Y+ Z / !P Q '0'..'9'*

is equvalent to:

eg
	R = ( (X (Y+) Z)
	  / ((!P) Q ('0'..'9')*) );

A rule definition may use an explicit [:";"] as a terminator, and this allows multiple rules to appear on the same line. A rule may continue on the next line if there is a choice [:"/"] or an unclosed bracket, but each line is taken as a group expression so an explicit comma [:","] or parenthesis are required to continue a sequence group into the next line.


Sub1	Choice Operators

The first sequential choice operator, written as [:X / Y], will first try to match :X, and only if that fails will the second choice :Y be matched. This is the [ref:PEG] sequential choice operator.


Sub1	Repeat Operators

The repeat operators are:

eg
	X?		optional match		X / ''
	X*		zero or more		Xs = X Xs.. / ''
	X+		one or more		Xp = X Xp.. / X

The repeat operators are "greedy" and will find the longest match, and no other.

The traditional [ref:EBNF] notation is also available:

eg
	{ X }		zero or more X, same as X*
	[ X ]		optional X, same as X?

The number of repeats may be specified explicitly, for example:
 
eg
	X*4		match exactly 4 times
	X*4.._		match 4 or more times
	X*4..8		match a min of 4 to a max of 8 times


Sub1	Literal Values

Literal character values can be expressed in various ways:

eg
	'a'		literal char, or	97
	'a'..'c'	range of chars, or 	97/98/99, or 97..99
	'abc'		literal string		97 98 99
	''		empty string		never fails

Literal characters boil down to integer values, which will normally be interpreted as Unicode character code points. A Gist parser implementation must be able to accept input text characters encoded as Unicode values (integers) and may also accept other encodings, such as UTF-8 (a UTF-8 encoding uses 1 or more bytes of input to represent a code point). A Gist grammar will normally specify Unicode characters, but it can be used to specify other data formats, such as an octet sequence for a low-level message format.

Grammar rules to match white-space characters are required by most grammars. The [ref:Posix] definition for whitespace characters is:

eg
	space : 9..13/32

This includes space, tab and line-end characters. But the Unicode Zs Separator-space character category includes many other space characters:

eg
	Zs : 32/0xA0/0x1680/0x180E/0x2000..200A/0x202F/0x205F/0x3000

A more complete rule for white-space characters includes both these rules plus other line and paragraph separator characters:

eg
	sp : space/Zs/0x85/0x2028..2089

---
Matching any number of white-space characters is such a common requirement that Gist defines the [:~] symbol for this purpose, it has a built-in definition corresponding to:

eg
	~ : sp*
---

The [ref:IETF] defines an Internet line-end as carriage-return line-feed:

eg
	crlf : 13 10

However, the Unix standard is a single line-feed character, and a single carriage-return is also sometimes used, while Unicode defines a different line-end code, and main-frame systems have yet another line-end character. The [ref:XML] standard normalizes all of these common standards into the Unix standard line-feed.

A new-line rule to match all these common conventions can be defined as:

eg
	nl : 13 (10/0x85)? / 10 / 0x85 / 0x2028

---
Gist defines the [:$] symbol to match a new-line separator:

eg
	$ : nl

A [:_] symbol is defined to match any Unicode character:

eg
	_ : 0x0..10FFFF
---

A match for any character is sometimes convenient, but it can be dangerous since it will match control characters, permanently undefined characters, and more. An XML document can contain almost any Unicode character, but not everything. A reasonable set of characters compatible with XML 1.1 can be defined as:

eg
	char: 8..10/13/0x20..7E/0x85/0xA0..D7FF/0xE000..FDCF/0xFDC0..FFFD/0x10000..10FFFD

Replicating this sort of definition is cumbersome and tedious, a better way is to use an external reference to a library of common standards.


Sub1	Negation

The not-predicate [:!X] says that an expression :X will ~not match.

Negation is a very powerful tool to simplify grammar rules and to increase their expressive power. The Gist negation is the same as the [ref:PEG] negation, but other grammar languages provide different treatments, like most traditional context-free grammar languages [ref:ABNF] has no negation, while the [ref:XML] [ref:EBNF] has two different forms, neither of which are very satisfactory.

A simple use of negation is to exclude particular characters from a character set. For example, to match a quoted string:

eg
	quote : quot (!quot char)* quot
	quot  : 0x22
	char  : 9..126

Another way to express this is to use the expression: [:(char~quote)] which will match a :char except if a :quote would match, this is exactly the same as: [:(!quot char)], but it may be easier to read:

eg
	quote : quot (char~quot)* quot
---
Another way to express this is to use the expression: [:(char-quote)] which will match a :char except if a :quote would match, this is exactly the same as: [:(!quot char)], but it may be easier to read:

eg
	quote : quot (char-quot)* quot
---

The parser can compile either of these rules to the equivalent rule:

eg
	quote : 0x22 (0x9..21/0x23..FE)* 0x22

The regular expression notation [:[^"]*] represents zero or more characters that are ~not a quote character, and this looks even simpler, but it is less satisfactory since the domain of all such characters is not specified in the grammar. For example it will include zero, other control codes and Unicode non-characters. In fact the use of this notation in the EBNF XML 1.0 specification introduced errors in that grammar.

The [:!] notation is not restricted to defining character-sets, it works just as well with a string (or any other expression). For example, to specify the syntax for comments of this form: [:/* comment lines... */] where the comments may include any number of :char while there is ~not a match for the terminator [:'*/'] characters:

eg
	comment : '/*' (!'*/' char)* '*/'
	char    : 0x9..10FFFD

As before, the expression: [:(char~'*/')] can be used to express the same thing. It will match a :char except if a [:'*/'] would match, but in this case there is no way to reduce this into a simple character set.
---
As before, the expression: [:(char-'*/')] can be used to express the same thing. It will match a :char except if a [:'*/'] would match, but in this case there is no way to reduce this into a simple character set.
---

A positive assertion that a rule ~would match, but without matching any input, can be expressed as [:!!x], and this can also be written as [:&x], the PEG notation.

eg	&X	-- look-ahead predicate confirms that X would match

Negation of an arbitrary rule is a powerful concept and it allows a grammar to specify some languages that are not context-free.


Sub1	Same Match Operator

The [:@] operator is a context-sensitive operator that allows a grammar rule to use prior information from the (partial) parse tree constructed from the preceding input string.

eg
	@name	-- matches the same string that the prior name rule matched

The prior node is defined as the closest node generated with the given name that is a previous sibling node, or a parent, or a previous sibling of the parent, and so on back up to the root node.

This operator enables a Gist grammar to define languages that are beyond context-free grammar rules. It is rarely needed, but there are a few practical language features that can not be defined without it. Some examples are given a little later.


Sub1	Silent Match

A back-tick prefix [:"`"] can be used to invoke a rule without generating a parse tree node. This makes no difference to the syntax defined by the grammar rules, it only effects the parse tree that will be generated.

For example, the next grammar defines a list of :int terms separated with :sep terms, but the back-tick prefix eliminates the :sep term from appearing in the parse tree:

eg
	list  = int (`sep int)*
	int   : '0'..'9'+
	sep   : s* ',' s*	-- comma and whitespace
	s     : 9..13/' '	-- white-space

The input: [:"12, 3, 45"] will generate the parse tree:

eg
	list
		int "12"
		int "3"
		int "45"


Sub1	Events

Events provide an escape mechanism to enable a Gist parser to interact with an external application program. They can be used as a debug tool, and they enable an application to process events "on-the-fly" as the parse proceeds. It is best to avoid events in shared grammar specifications.

An [:<event>] can be inserted anywhere in a grammar, and whenever the parser reaches that point in evaluating a grammar rule it will invoke an interface or generate a event message, and wait for the application environment to respond. A default event handler can simply print out the name of the event and a progress report to trace the progress of the parser showing the scanner position in the input string.

An event interface allows a parser to send parsed terms to an application before a complete parse tree is constructed. This can be useful if the parse tree is expected to be very large, or if the input is a stream with an unknown duration. Any Gist grammar can be used to implement an event driven model by adding named event elements into the grammar rules at any desired point, and writing an application processor to handle the event stream.

The event interface should also allow an application to cause the parse to fail, or to consume additional input,  and to abandon parse tree elements that are no longer required.

This enables events to be used to implement arbitrary input matchers, constraints and semantic methods.


Sub1	External References

Gist can define a rule via a reference to a separate grammar. This enables a grammar to be composed in modules, and supports the use of common standard rules.

For example, a :digit rule can refer to the :Nd, Numeric-digit defined in a [:Unicode.category] grammar:

eg	digit -> Unicode.category#Nd

If the local rule uses the same name as the rule in the external grammar then simply: 

eg	Zs -> Unicode.category

When multiple rule names refer to the same names in an external grammar then a catch-all reference can be used for convenience:

eg
	_ -> Unicode.category

Multiple catch-all references will be searched in the order they are given.

Rule names must be unique within a grammar, but external references can import different rules from different grammars that have the same rule name. The parse tree nodes use rule names, but they can be distinguished by their path names in the parse tree. Grammars are named in a separate name space, and these names do not appear in the parse tree.

A grammar may be given almost any name, but for grammars to be shared they need a globally unique name, so a good practice is to use a standard [ref:URI]. The extension [:#name] to designate a rule name within a grammar fits the general URI format. A URI can also lead to related web-pages with other documentation and resources provided by the URI web-site authority.


Sub1	Language Details

A Gist grammar can be used as a stand alone specification, but it can also be employed inside different application programming languages. To reduce distractions with the host programming language Gist accepts line comments with several common conventions:

eg
	--	as in Haskell or XML-like comments
	//	as in C or Java style
	#	as in a Shell or Ruby script language style

The Gist language avoids using the quote [:"] and backslash [:\] characters to simplify the use of grammar rules in a literal string inside application programming languages where these characters may need to be escaped.




Sect	Some Examples

Sub1	Arithmetic Expressions

The next examples use arithmetic expressions to show a couple of different grammar design options. The first version is simple and efficient, the grammar implements operator precedence, but left association remains for the application to evaluate:

eg
	Exp   = Mul (sum Mul)*
	Mul   = Val (mul Val)*
	Val   = int / '(' Exp ')'
	sum   : '+' / '-'
	mul   : '*' / '/'
	int   : '0'..'9'+

The parse tree for [:1+2*(3-6/3+1)] is:

eg
	Exp
		Mul	Val	int	"1"
		sum	"+"
		Mul
			Val	int	"2"
			mul	"*"
			Val	Exp
				Mul	Val	int	"3"
				sum	"-"
				Mul
					Val	int	"6"
					mul	"/"
					Val	int	"3"
				sum	"+"
				Mul	Val	int	"1"

This parse tree is shown in a compact format that allows a singleton child to appear on the same line a its parent. Sibling children are aligned in a column with the same inset, which shows the nesting level, but extra inset levels are not required after singleton parents. The tree structure should be apparent after a little study. Larger parse trees are much easier to read with this format.

The next example uses left recursion to express left association:

eg
	Expr  = Exp
	Exp   = Add / Sub / Item
	Add   = Exp '+' Item
	Sub   = Exp '-' Item
	Item  = Mul / Div / Val
	Mul   = Item '*' Val
	Div   = Item '/' Val
	Val   = Int / '(' Exp ')'
	Int   : '0'..'9'+

The parse tree for [:1+3*(5-6/3+2)] is:

eg
	Expr
		Exp	Add
			Item	Val	Int	"1"
			Item	Mul
				Item	Val	Int	"3"
				Item	Val	Exp	Add
					Exp	Sub
						Item	Val	Int	"5"
						Item	Div
							Item	Val	Int	"6"
							Item	Val	Int	"3"
					Item	Val	Int	"2"

An application can walk through either of these parse trees to evaluate the expression. The first tree requires the application to iterate over a flat list of children nodes and implement left association, but that is not difficult.



Sub1	The JSON Data Language

JSON is a text data language that is available in almost every programming languages. It represents a collection of name/value pairs: [:{ "name": value, ... }], that is realized in various languages as an object, record, struct, dictionary, hash table, keyed list, or associative array. It also represents an ordered list of values: [:[ value, ... ]], that is realized in most languages as an array, vector, list, or sequence. 

The Gist grammar follows directly from the [ref:JSON] specification:

eg
	json   =~ (object / array)            
	object = ~ '{' pairs? '}'                
	pairs  =.. pair (',' pair)*             
	pair.. =.. string ':' val                
	array  =.. '[' vals? ']'                 
	vals   =.. val (',' val)*                 
	val    = object/array/string/number        
	         /true/false/null                  
	string = quot.. (chs/esc)* quot..            
	esc    = bs.. (code / 'u' hex)              
	number = neg? digits frac? exp?            
	frac   = '.' int                           
	exp    = ('e'/'E') sign? int               
	char   : 0x20..10ffff ~ quot ~ bs          

eg
	json   = ~ (object / array) ~              
	object = '{' ~ pairs? ~ '}'                
	pairs  = pair (~ ',' ~ pair)*             
	pair   = string ~ ':' ~ val                
	array  = '[' ~ vals? ~ ']'                 
	vals   = val (~','~ val)*                 
	val    = object/array/string/number        
	         /true/false/null                  
	string = quot.. (chs/esc)* quot..            
	esc    = bs.. (code / 'u' hex)              
	number = neg? digits frac? exp?            
	frac   = '.' int                           
	exp    = ('e'/'E') sign? int               
	digits : '0'/'1'..'9' digit*               
	int    : digit+                            
	digit  : '0'..'9'                          
	sign   : '+'/'-'                           
	neg    :  '-'                              
	true   : 'true'                            
	false  : 'false'                           
	null   : 'null'                            
	hex    : (digit/'a'..'f'/'A'..'F')*4       
	code   : bs/fs/quot/'b'/'f'/'n'/'r'/'t'     
	bs     : 92   -- back-slash                
	fs     : 47   -- forward-slash             
	quot   : 34   -- double-quote              
	chs    : char+                             
	char   : 0x20..10ffff - quot - bs          

Here is a JSON example (modified from [ref:RFC 4627]):

eg
	{
	   "Image": {
	       "Width":  800,
	       "Height": 600,
	       "Title":  "View from:\t15th Floor",
	       "Thumbnail": {
	           "Url":    "http://www.example.com/image/481989943",
	           "Height": 125,
	           "Width":  "100"
	       },
	       "IDs": [116, 943, 234, 38793]
	     }
	}

The parse tree is:

eg
	json	object	pairs
		pair
			string	chs	"Width"
			val	number	digits	"800"
		pair
			string	chs	"Height"
			val	number	digits	"600"
		pair
			string	chs	"Title"
			val	string
				chs	"View from:"
				esc	code	"t"
				chs	"15th Floor"
		pair
			string	chs	"Thumbnail"
			val	object	pairs
				pair
					string	chs	"Url"
					val	string	chs	"http://www.example.com/image/481989943"
				pair
					string	chs	"Height"
					val	number	digits	"125"
				pair
					string	chs	"Width"
					val	string	chs	"100"
		pair
			string	chs	"IDs"
			val	array	vals
				val	number	digits	"116"
				val	number	digits	"943"
				val	number	digits	"234"
				val	number	digits	"38793"

An application program can then translate the parse tree into native programming language objects. The grammar rules can be arranged to help supports the application. For example, the :string rule collects a sequence of characters together as far as possible and identifies escaped characters. This helps the translator iterate through the content of a string to build a native programming language string.


Sect	Eliminating Multi-match Rules

The JSON specification uses traditional grammar rules that allows multi-match rules, yet they are intended to act as one-match rules, and can be transcribe directly into Gist one-match rules. This is usually the case, but sometimes a specification relies on multi-match being able to back off the first longest match and use a shorter match instead. These rules need to be detected and reformulated into one-match rules.

If :X and :Y are mutually exclusive, and :X can not match an empty string, then the one-match [:(X/Y)] rule is the same as the multi-match rule [:(X|Y)]. But a multi-match choice that is not mutually exclusive can match either choice, whereas a one-match choice will only match the first choice. Reversing the order of the [:(X/Y)] choice may be required, otherwise it may be necessary to re-factor and match in steps.

A multi-match repeat rule can match a list of items as [:(X* Y)] even when an :X can also match a :Y. This takes advantage of the fact that a multi-match repeat can back-off from the last :X to accommodate the following :Y. The :X may match a prefix (or all) of :Y, but the grammar can still distinguish the last element. This is a common trick in regular expressions where the [:X*] may skip every character, but backtracking still allows the :Y to be matched at the end of the input.

For example, here is a traditional multi-match rule that would fail as a one-match rule. It matches :p or :q any number of times, but they must be followed by a :q :

eg	S ::= (p|q)* q    -- "q", "qq", "pq", "pqq", "ppq", "pqpq", "pqpqq", and so on...

The repeat operator will first match every :p or :q, so the following :q must fail, and a one-match version of this rule will fail. But the multi-match rule can back-track to a shorter sequence in the repeat operator, and thereby match the final :q.

The ~shortest string ending with a :q is simply:

eg	S = p* q

This ~longest string of :p or :q that ends with a :q can be expressed as:

eg	S = (p* q)*

This one-match rule matches the same longest string as the original multi-match rule.

A general approach for a longest one-match rule is to use a not-predicate to stop the repeat operator from matching an end condition:

eg	S = (p / q !end)* q

The end condition may match the end of the input string (not any character), or some other termination syntax.


Sect	Context Sensitive Grammars

Almost all computer languages are defined with a context-free grammar, and the vast majority of practical applications are well covered. But there are a few important exceptions that require context-sensitive grammar rules.

Sometimes the context-sensitive constraints do not need to be enforced by the parser, and an application program can process the parse tree later to verify the required constraints. The XML grammar is an example of this, the grammar rules do not enforce several constraints, including the constraint that start and end tags must be the same name. However there are some grammars that can not be parsed at all without a context-sensitive grammar.

Sub1	Using The Same Match Operator

A language with an expression that starts with a particular label and must end with the same label needs a context free grammar. A context-free grammar would require a rule for every possible label, which may not be practical or possible.

Gist provides a prior match operator [:@X]:

eg	S = X Y @X

The [:@X] matches the same string that the previous :X matched, and since Gist is a top-down recognizer this will have already been matched. This can be implemented by looking back into the (partial) parse tree, finding the previous :X, and using the value of that match to match the same string again.

The fact that an XML element's start and end names must match is expressed as a constraint, outside the context-free grammar:

eg	element = '<' name '>' content '</' name '>'  -- same_match 'name'

Gist allows this constraint to be included in the grammar:

eg	element = '<' name '>' content '</' @name '>'

Notice that the :content may include a nested :element so the prior :name is not simply the last time that the [:name] rule was matched. The parse tree provides the context for the [:@name] operator to search back through the previous sibling nodes to find the previous :name node. The search may continue prior to the parent node through its prior siblings, and so on back to the root of the parse tree. This procedure will work in a recursive descent parser even when all the parent nodes have not yet been created.

It is not always possible to postpone a same-match constraint, and in these cases the constraint must be enforced in the grammar. Examples include the multi-part MIME message format, the here-documents in the Ruby language, and in general any indentation nested block structure such as the indentation and off-side rules for Python and Haskell.

A Ruby "here-document" allows blocks delimited by a distinct identifier, like this:

eg
	text = <<-id1234
	A "here document" is useful since it can contain
	anything except a line with only id1234...
	id1234

The :id1234 can be any identifier, and the Gist grammar for this can be expressed as:

eg
	here_doc = '<<-' id hdoc end
	hdoc     : nl (!end line nl)*
	end      : blank* @id nl
	id       : alpha alnum*
	line     : print*

The full Ruby syntax is more complicated, but this is the gist of it.

Sub1	Off-side Rules

A computer programming language is said to employ an off-side rule if it uses indentation to express nested scope of declarations, [ref:off-side].

The ABNF specification uses an off-side rule to allow a grammar rule to continue on the next line provided that each following line has a larger inset than the inset of the first line of the rule. This is simple to define informally, and it is easy to use, but it requires a context-sensitive grammar since the inset margin for the first line of a rule can be an arbitrary width.

The [:@] same-match operator can be used to define this off-side rule. It allows subsequent lines to be "folded" under the first line with a larger inset:

eg
	lines  = inset line (fold line)*
	inset  : sp*  -- any width space
	fold   : nl @inset sp+  -- a longer space on the next line

In general an inset text block can be specified as a number of lines with the same whitespace inset:

eg
	block  = inset line (nl @inset line)*
	inset  : blank*

This can be extended to an indentation structure with nested blocks:

eg
	block  = inset line (nl (&indent block / @inset line))*
	inset  : blank*
	indent : @inset blank

The [:&] predicate checks if a rule matches without consuming any input, so the [:&indent] will match the first line of a nested block with an indent that is larger than the current inset.

An interesting application is to check for a miss-match between the syntax of a programing language and its visual layout. For example, a ambiguous dangling :else is usually associated with the nearest :if, but the visual indentation may conflict with that:

eg
	if a then
		if b then x
	else y

Gist grammar rules can be defined to generate the standard nesting: [:(if a then (if b then x else y))], or using the [:@] operator it can define the parse tree corresponding to the visual indentation: [:(if a then (if b then x) else y)].

eg
	expr = if / ...
	if   = inset 'if' test 'then' expr (@inset 'else' expr)?


Sub1	Precondition Predicates

A precondition is some element in the input text that allows the grammar to discriminate between different grammar rules that would otherwise be ambiguous. For example, to distinguish a European from a US date format we could write [:"d/m/y 9/11/2001"], for a Euopean date, and [:"m/d/y 9/11/2001"], for a US date.

The format key [:"d/m/y"] or [:"m/d/y"] acts as a precondition that selects the appropriate grammar rules:

eg
	Date = 'd/m/y' sp day '/' month '/' year
	     / 'm/d/y' sp month '/' day '/' year

But it is tedious to require that the format key to be repeated prior to every date, so we might like to allow the format key to appear only once, as a precondition early in the input text. Multiple dates that occur later in the text will depend on the preselector. A context-free grammar to express this is quite awkward since the grammar rules have to be split into two sets of rules following the rule that matches the precondition. A larger grammar with more preconditions becomes quite impractical.

The next grammar uses a :select rule that can be matched matched early in a input, and this rule generates either a :dmy or a :mdy terminal node in the parse tree. The :Date rule can then use the [:@dmy] (or [:@mdy]) to look back in the parse tree and determine if a :dmy (or :mdy) has a prior match. The trick is that these rules match an empty string, so they will always match again at the current position:

eg
	select = 'd/m/y' dmy / 'm/d/y' mdy
	dmy    : ''
	mdy    : ''
	...
	Date = @dmy sp day '/' month '/' year
	     / @mdy sp month '/' day '/' year

The :dmy or :mdy are used as preconditions, to match a :Date one or other of them must appear earlier in the parse tree.


Sect	Gist Parser

Gist requires a top down parser. A recursive descent parser is a simple and elegant way to parse grammar rules, but  the implementation needs to be extended to handle left recursion, and to address the concern that a grammar may (at least in theory) require an exponential parse time [ref:Parsing].

A cache memory for parse results, called memos, can be used to implement left recursion, and also to control any exponential time explosion. For a Parser Expression Grammar a packrat parser uses a cache to achieve a linear parse time performance [ref:PEG].

There is a conflict between the use of memos for left recursion and their general use for performance. A memo can only be used for a rule that has a fixed result, and not all Gist rules generate a fixed result. The context sensitive operator [:@] or an [:<event>] may not have fixed results, and left recursive rules are not fixed since they contain nested results that match from the same input position.

A memo cache also has a memory and performance overhead of its own, and for simple grammars the penalty can be larger than the benefit.

Fortunately it is possible to use a lazy cache scheme that only employs a memo when it is both safe and beneficial. The lazy cache scheme uses light-weight memos that enable left recursion and enhance performance, but impose very little overhead, see: [ref:LazyCashinParser].

For an implementation of a Gist parser in Java see: [ref:GistJava].


Sect	Conclusions

Gist provides a grammar language that can be automatically executed to generate a well defined parse tree structure.

The Gist rules are a form of [ref:PEG] (Parser Expression Grammar) that can be seen as a way to match input strings, as against the traditional production rules that are used to generate sentences in a language.

It is useful to be able to directly execute a grammar specification even if the end objective is a paper specification rather than an operational parser. Iterative modifications and corrections of grammar specifications are essential during development, and Gist allows direct incremental testing of a grammar as it is developed.

A universal parser makes it easier to design and experiment with grammar rules for an application, rather than trying to reverse engineer them from a prototype program. It also makes it much easier to modify and extend an application to accept new input formats. 

Every rule in a traditional context-free grammar is a multi-match rule, but in practice only one-match PEG rules are needed. Context-free languages that can not be expressed with one-match rules do exist, but they do not seem to be needed in practice. 

On the other hand some practical applications are beyond a context-free grammar and Gist has context-sensitive extensions to cover these requirements.

Gist demonstrates a concise formal grammar specification with minimal extra notation that enables direct execution with a practical universal parser.


Sect	References

define
	ABNF
		Augmented Bakus Naur Form, see: [http://www.ietf.org/rfc/rfc5234.txt?number=5234]
	
	ANTLR
		ANTLR Another Tool for Language Recognition, [http://www.antlr.org/]

	BNF
		Bakus Naur Form, see: [http://en.wikipedia.org/wiki/BNF]

	EBNF
		Extended Bakus Naur Form, see: [http://en.wikipedia.org/wiki/Extended_Backus_Naur_Form] and the XML version of EBNF: [http://www.w3.org/TR/REC-xml/]
		
	Gist
		Grammar Intrinsic Syntax Tree, see: [http://gist.spinachtree.org/gist]

	GistJava
		Gist in Java: [http://spinachtree.org/gist/java]

	grammar theory
		Grammar theory: [http://en.wikipedia.org/wiki/Formal_grammars]

	IETF
		Internet Engineering Task Force, develops and promotes Internet standards:  [http://en.wikipedia.org/wiki/IETF]
	JSON
		JavaScript Object Notation, despite its name it is independent of JavaScript, see: [http://www.json.org/]
	LazyCashinParser
		A parser designed to implement Gist: [http://spinachtree.org/gist]

	off-side
		The use of indentation for programming language scope: [http://en.wikipedia.org/wiki/Off-side_rule]
	parser technology
		Parser technology: [http://en.wikipedia.org/wiki/Parsing]
	Parsing
		see: [http://en.wikipedia.org/wiki/Parsing]
	Parsing Techniques
		Parsing Techniques, A Practical Guide. Dick Grune, Ceriel J. H. Jacobs, Springer, ISBN-13: 978-0-387-20248-8. [http://www.cs.vu.nl/~dick/PTAPG.html]
	PEG
		Parser Expression Grammar: [http://pdos.csail.mit.edu/~baford/packrat/thesis/]
	
	Parser Expression Grammar
		An analytic formal grammar, see: [http://en.wikipedia.org/wiki/Parsing_expression_grammar]

	Posix
		Portable Operating System Interface [for Unix], an IEEE standard that defines ASCII character code sets used in some regular expression implementations. [http://en.wikipedia.org/wiki/POSIX]
	
	RFC 4627
		JSON data language, IETF standard RFC4267,
		see: [http://www.ietf.org/rfc/rfc4627.txt]
	
	URI
		WWW Uniform Resource Identifier: [http://en.wikipedia.org/wiki/Uniform_Resource_Identifier]
	
	XML
		Extensible Markup Language: [http://en.wikipedia.org/wiki/XML]

format
	Title	h1:prose
	Author	h2:prose
	Date	h3:prose
	Sect	h2:prose
	Sub1	h3:prose
	Appendix	h2:prose
	para	p:prose
	eg	pre:text
	
prose
	:_	tt:text
	~_	em:prose
	"_"	quote:prose
xxx
	[ref:_]		<undefined>[%text]</undefined>
	[ref:?]		<a href="#%text">%text</a>
	[http:_]	<a href="http:%text">http:%text</a>


style
	undefined { color:red; background-color:yellow; }
	.title, .author, .date { text-align: center; }
	.eg { background-color:#FFFDDA; border: thin solid #ECECEC; }
	.format, .style { display:none; }




