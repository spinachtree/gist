
title	The Gist Grammar Language


sect	Introduction

The Gist grammar language looks very much like a traditional #BNF grammar language, and it can be used to replace a traditional #ABNF or #EBNF specification. But the Gist grammar rules can also be executed directly. An automated parser can generate a parse tree that is implicitly defined by the grammar rules.

This means that a designer can incrementally verify the grammar rules as they are designed. It is easy to provide input strings to demonstrate the design intent and to provide verification test cases. An Gist parser is a huge help to a grammar designer, and hours of painstaking proof reading of formal specifications can be transformed into iterative experimentation and verification. Much more productive, and much better fun.

Similar benefits are available from a parser generator development environment, such as #ANTLR, which has impressive graphics and debug facilities. The difference is that Gist has a tight focus on the grammar specification itself, everything is in the grammar rules. A Gist grammar can be used in an ANTLR development environment, and developed into a industrial strength parser for a particular grammar. But the Gist rules are stand alone, they are a complete specification, and a universal Gist parser can execute any Gist grammar.

If a Gist automated parser is available in your programming language (or you write one of your own) then you can use it directly in your applications. The Gist parser will generate a parse tree for ~any Gist grammar in a ~standard parse tree structure. That's great for productivity, and you can always build a ~custom parser for a ~particular Gist grammar if ultimate performance is essential.

Although Gist looks very much like traditional grammar rules it is based on "one-match" rules that are a form of parser expression grammar, #PEG. In practice the "one-match" interpretation is used by most EBNF or ABNF specifications, but some rules may need to be re-formulated. The expressive power of a Gist grammar goes beyond traditional context-free grammar rules.


sect	Gist Features


*	Specifications in a traditional EBNF style.
	
*	A simple top-down interpretation, but left recursive rules are allowed.

*	Analytic one-match rules with a PEG interpretation.

*	Rules define an implicit parse tree structure.

*	Terminal string matching rules for clarity and efficiency.

*	External grammar rule references for modularity and standard library rules.

*	Expressive power for useful context-sensitive grammars.

*	Hooks to enable an event driven incremental parser.

*	An escape-hatch to invoke external semantic methods for special purpose extensions.

*	A fully automated universal parser (currently only a Java version).


sect	To Learn More

You will find a collection of documents and software at: @[http://spinachtree.org/gist]


sect	References

refs
	ABNF
		Augmented Bakus Naur Form, ~see: @[http://www.ietf.org/rfc/rfc5234.txt?number=5234]	
	ANTLR
		ANTLR Another Tool for Language Recognition, @[http://www.antlr.org/]
	BNF
		Bakus Naur Form, see: @[http://en.wikipedia.org/wiki/BNF]
	EBNF
		Extended Bakus Naur Form, see: @[http://en.wikipedia.org/wiki/Extended_Backus_Naur_Form] and the XML version of EBNF: @[http://www.w3.org/TR/REC-xml/]		
	Gist
		Grammar Intrinsic Syntax Tree, see: @[http://spinachtree.org/gist]
	Gist in Java
		Gist in Java: @[http://spinachtree.org/gist/java]
	PEG
		Parser Expression Grammar: @[http://pdos.csail.mit.edu/~baford/packrat/thesis/]
	Parser Expression Grammar
		An analytic formal grammar, see: @[http://en.wikipedia.org/wiki/Parsing_expression_grammar]

format
	title	h1:prose
	sect	h2:prose
	sub1	h3:prose
	para	p:prose
	eg	pre:text
	refs	dl:format
	*	ul:format

prose
	:_	tt
	~_	em
	"_"	quote
	#_	linkID
	@[_]	link

style
	.undef { color:red; background-color:yellow; }
	.title, .author, .date { text-align: center; }
	.eg { background-color:#FFFDDA; border: thin solid #ECECEC; }
	dl { font-size:small;}
	dl dd p { margin: 0pt 0pt 10pt 0pt; }
	.format, .prose, .style { display:none; }





