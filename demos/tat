
title	TAT: a simple text format for data structures.

TAT (Tag Any Text), is a text format for any mix of structured and unstructured text. It can be used as an alternative to XML, Json or YAML. The TAT format can contain any mix of prose text paragraphs, mark-up language items, data language items or programming language items. There are no restrictions of the syntax of the text in TAT items.

A TAT document is interpreted as a list of items that contain a head and a body. Prose paragraphs appear as items with a head but no body. Other items may use the head text as a tag label for the body. The interpretation of the body text is entirely determined by how an application interprets the tag label.

For Gist it allows grammar specifications to be embedded in a prose document: a Gist processor can extract the "gist" tag grammar rules and "parse" tag input samples. Other tag labels are ignored, but an HTML processor may use them to translate the same TAT document into a nice looking web page.

gist
	tat   = item*
	item  = head? (`neck body)? `foot
	head  : graph text (nl graph text)*
	neck  : vert* tab
	body  = line (`vert+ `tab line)*
	foot  : (!vert any)* vert*
	text  : (sp|graph)*
	line  : (tab|sp|graph)*
	nl    : 10 / 13 10?
	vert  : 10/13
	tab   : 9
	sp    : 32
	graph : 33..1114111
	any   : 1..1114111

parse
	title	A Little example
	
	First a little para
	of prose...
	
	book
		title	A Good Book.
		author
			name	A Author
			email	author@office
		isbn	123456789

The "book" item has a "body" that contains a nested data structure. If you strip the inset tabs then the TAT grammar can be applied yet again, this time the top level elements are "title", "author" and "isbn, and "author" contains a nested "body" that can be handled in the same way.

Now lets parse the full nested structure with a one-parse grammar. This can not be expressed as a context free grammar unless we are prepared to have a copy of the grammar for each nesting depth (with an increasing inset). But a context sensitive grammar can look back and match the same inset again using @=inset. We can check for a nested block by matching the previous inset, @=inset followed by another tab.

gist
	tat   = (item `vert*)*
	item  = inset head? body?
	inset : tab*
	head  : graph text (nl @=inset graph text)*
	body  = `tab+ line / (`vert+ &(@=inset `tab) item)*
	text  : (sp|graph)*
	line  : (tab|sp|graph)*
	nl    : 10 / 13 10?
	vert  : 10/13
	tab   : 9
	sp    : 32
	graph : 33..1114111
	any   : 1..1114111

parse
	title	A Little example
	
	First a little para
	of prose...
	
	book
		title	A Good Book.
		author
			name	A Author
			email	author@office
		isbn	123456789
