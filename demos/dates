
An example of context sensitive grammar rules.

Fist a basic date grammar, simple and practical...

gist
	date  = year '-' month '-' day
	year  : d d d d
	month : d d?
	day   : d d?
	d     : '0'..'9'

parse
	2001-2-3

Now with better numeric ranges: 1000..2999 '-' 1..12 '-' 1..31  ...

gist
	ymd   = year '-' month '-' day
	year  : '1'..'2' d d d                              -- 1000..2999
	month : '0'? '1'..'9' | '1' '0'..'2'                -- 1..12, inc 01..09
	day   : '0'? '1'..'9' | '1'..'2' d | '3' '0'..'1'   -- 1..31, inc 01..09
	d     : '0'..'9'

parse	2001-2-3
fail	2001-0-3

Maybe that is better, but it still allows every month to have 1..31 days. This could be fixed, but
without context sensitive grammar rules it becomes quite messy -- try it!

The @ operator is a context sensitive operator that looks back into the (partial) parse tree to see what has matched,
and this allows us to specify 1..29 days for any month, or 30 for particular months, and 31 for the others:

gist
	YMD     = year '-' month '-' day
	year    : '1'..'2' d d d                              -- 1000..2999
	month   = feb | sajn | rest                           -- 30 days hath sep. apr. june. and nov...
	feb     : '0'? '2' 
	sajn    : '0'? ('9'|'4'|'6') | '11'                   -- sep. apr. june. and nov.
	rest    : '0'? ('1'|'3'|'5'|'7'..'8') | '10' | '12'
	day     : '0'? '1'..'9' | '1'..'2' d                  -- 1..29
	        | @month.sajn '30'                            -- fails unless sajn was matched
	        | @month.rest '3' '0'..'1'
	d       : '0'..'9'

parse	2001-1-31
fail	2001-2-30

The day rule uses the @month.sajn predicate to look back in the syntax tree to find the prior sibling month, and to look inside the month node to see if it was matched using a sajn (or a rest) rule.

The next example copes with leap years....

gist
	Date  = year '-' month '-' day
	year  = leap / norm
	leap  : ('19'|'2' '0'..'3') !'00' d ('0'|'4'|'8') / '2000'
	norm  : ('19'|'2' '0'..'3') d d                    -- 1900..2399
	month = feb | sajn | rest                          -- 30 days hath sep. apr. june. and nov...
	feb   : '0'? '2' 
	sajn  : '0'? ('9'|'4'|'6') | '11'                  -- sep. apr. june. and nov.
	rest  : '0'? ('1'|'3'|'5'|'7'..'8') | '10' | '12'
	day   : '0'? '1'..'9' | '1' d | '2' '0'..'8'       -- 1..28
	      | @month.feb @year.leap '29'
	      | @month.sajn ('29'/'30')
	      | @month.rest ('29'/'30'/'31')
	d     : '0'..'9'

parse	2004-2-29
fail	2005-2-29

All well and good, but is it really worth it? Its usually best to keep the grammar rules as simple as
possible and let the application verify if the input data is valid.

I think the original simple date format was good enough, it specifies the syntax for a basic date
format, without getting into the semantics, but its a fuzzy boundary.

In practice context sensitive grammars are almost never needed, but in a few cases they are essential.

