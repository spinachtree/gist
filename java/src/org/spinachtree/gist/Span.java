
package org.spinachtree.gist;

/**
Span nodes represent the syntax tree.

<p>
Span objects are a simple low level data structure created by the parser machine.
</p>
<p>
It is expected that most applications will use a transformed version of the Span tree, available
from the termTree() method on the Parse result object (see Term).
</p>
<p>
The spanTree() method on the Parse result returns the low level Span tree. The parser machine treats
Span objects as immutable. Span objects are open but there is no public constructor.
</p>
<p>
The Span tree structure is unusual, it is designed to be immutable and efficient for the low level
parser machine. Span tree nodes always refer to previous nodes, constructed earlier. The parent node
is created after the children.
</p>
<pre>
Example..
	R = a b S
	S = c
	a : 'a'
	-- parser machine generates Span records: {tag,tip,top}
	=>  0:NIL, 1:{a,0,0}, 2:{b,1,1}, 3:{c,2,2}, 4:{S,2,3}, 5:{R,0,4}
</pre>
*/


public class Span {
	
	// Span nodes represent the syntax tree 
	
	// Low level index records generated by PAM
	
	Span(int tag, int sot, int eot, Span tip, Span top, Span link) {
		this.tag=tag;  // ruleID
		this.sot=sot;  // start of text
		this.eot=eot;  // end of text
		this.tip=tip;  // floor, prior Span (prior to first child)
		this.top=top;  // last prior Span (last child)
		this.link=link;  // memo list
	}

	/**
	tagId of rule name.
	*/
	public int tag;       // rule name index, 1..N
	/**
	sot..eot index the matched input text.
	*/
	public int sot, eot;  // start and end string indexes
	/**
	tip is Span prior to any children, top is the last child.
	*/
	public Span tip, top;
	/**
	link to prior Span with same tag (memo cache link).
	*/
	public Span link;     // memo list
			
	static Span NIL=new Span(0,0,0,null,null,null);
	/**
	last child
	*/
	public Span last() {
		if (tip==top) return null;
		return top;
	}
	/**
	first child
	*/
	public Span first() {
		if (tip==top) return null;
		Span x=top; // last child
		while (x.tip!=tip) x=x.tip;
		return x;
	}
	/**
	alias first child
	*/
	public Span span() { return first(); }
	/**
	first child with traget tag
	*/
	public Span span(int target) {
		if (tip==top) return null;
		Span x=top; // last child
		Span fit=null;
		while (x!=tip) {
			if (x.tag==target) fit=x;
			x=x.tip;
		}
		return fit;
	}
	/**
	children spans
	*/
	public Span[] spans()  {
		if (tip==top) return new Span[0];
		return top.siblings(tip,0);
	}
	
	Span[] siblings(Span floor, int cnt) {
		if (this==floor) return new Span[cnt];
		Span[] pre=tip.siblings(floor,cnt+1);
		pre[pre.length-cnt-1]=this;
		return pre;
	}
	/**
	children spans with target tag
	*/	
	public Span[] spans(int target)  {
		if (tip==top) return new Span[0];
		return top.siblings(target,tip,0);
	}
	
	Span[] siblings(int target, Span floor, int cnt) {
		if (this==floor) return new Span[cnt];
		if (tag==target) {
			Span[] pre=tip.siblings(target,floor,cnt+1);
			pre[pre.length-cnt-1]=this;
			return pre;
		}
		return tip.siblings(target,floor,cnt);
	}
	
	// child is an alias for span...... 

	public Span child() { return first(); }

	public Span child(int target) { return span(target); }

	public Span[] children()  { return spans(); }
	
	public Span[] children(int target) { return spans(target); }
	
	/**
	count total nodes in span tree....
	*/
	public int count() {return count(0);}
	
	int count(int n) {
		if (top==null) return n;
		return top.count(n+1);
	}
	
	// -- apply a memo --------------------------------------------------------------------------
	
	Span copy(Span from, Span to) {

		System.out.println("TODO: span copy for apply....");
		System.exit(-1);

		return NIL;
	}
	
} // Span